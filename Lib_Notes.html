<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="description" content="RePag-Softwareentwicklung">
  <meta name="author" content="Ren&eacute; Pagel">
  <meta name="keywords" content="RePag, Softwareentwicklung, RePag-Software, RePag-Bibliotheken, RePag-Libraries">
  <title>RePag - Libraries Notes</title>

  <link href="style.css" rel="stylesheet">

</head>
<body id="Seite">
  <header>
    <IMG width="145" height="65" src="Logo.gif" alt="Logo" title="RePag">
    <Banner>comming soon Open Air</Banner>
  </header>

  <nav>
    <div>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="Libraries.html">Libraries</a></li>
      </ul>
    </div>
  </nav>

  <section>
    <Text_n>
      Die Bibliothek GUL.dll wird von mir nicht mehr weiter entwickelt. Die Datei ist zum größten Teil in
      Assembler unter Verwendung des MMX und SSE Befehlssatz geschrieben.
    </Text_n>
    <P>
      <Text_n>
        Alle ADTs sind vollständig in Assembler geschrieben. Die Klassen COComma4 und COComma4_80 sind
        mit dem SSE2 und x87 FPU Befehlssatz geschrieben.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Bei den Funktionen FLOATzuCHAR() und DOUBLEzuCHAR() wird nur in der Darstellung gerundet. Der
        interne Wert bleibt unverändert. Bei Angabe von 8-Stellen bei FLOATzuCHAR() und bei der Angabe von
        16-Stellen bei DOUBLEzuCHAR() wird nicht gerundet. Stattdessen wird der echte Wert dargestellt mit
        dem der Prozessor in Wahrheit intern rechnet. Für eine 100% Genauigkeit, wie sie beispielsweise in der
        Finanzwirtschaft gefordert wird, empfehle ich die Verwendung von COComma4 und COComma4_80.
        Bei diesen beiden Datentypen wird nach kaufmänischen Runden entsprechend der DIN-Norm 1333
        gerundet.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Der ulZeilen_Blatt Parameter bei COTabelle stellt ein internen "Zeilen pro Blatt" Wert da. Die Anzahl der
        Blätter ist unbegrenzt. Stell dir vor du wärst der Computer. Wie hättest du es gerne? Viele Zeilen auf
        wenigen Blättern oder wenige Zeilen auf vielen Blättern oder alle Zeilen auf einen Blatt? Im Zweifelsfalle
        frag den Computer.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Da bei Mediadateien sehr große Datenmengen auftreten können wurde bewusst, wo möglich, auf eine
        Verarbeitung im Arbeitsspeicher verzichtet. Stattdessen erfolgt die Verarbeitung über die Festplatte.
        Bei Mediadateien die sich in Tabellen befinden werden jedoch vollständig in den Arbeitsspeicher
        geladen. Bei erreichen der physikalischen Speichergrenze wir das Exception EX_VM_KEINSPEICHER
        ausgelöst.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Alle Benutzerelemente und Dialog ab der Version 3.2 sind threadsicher. Jeder Dialog verfügt jetzt über
        eine eigene Messageschleife. Damit bleiben auch nichtmodale Dialoge bei der Funktion
        pDialog-&gt;SetzSichtbar(true) stehen. Mit der Message WM_COMMAND und
        wParam=IDE_DLG_SICHTBAR kann letztmalig hinter dieser Funktion Code ausgeführt werden oder
        erstmalig nach der Funktion pDialog-&gt;SetzSichtbar(true). Je nach Sichtweise. Diese Stelle ist auch die
        Empfehlenswerte für die Verwendung der Funktion Effekt_Timer() die im Gegensatz dazu im
        Konstruktor ungünstig platziert ist. Die Funktionen pDialog-&gt;ErstellFenster() und
        pDialog-&gt;SetzSichtbar(true) müssen im gleichen Thread ausgeführt werden, oder
        pDialog-&gt;ErstellFenster() in einem nicht beendeten Thread zum Beispiel dem Hauptthread und
        pDialog-&gt;SetzSichtbar(true) in einem beliebig anderen Thread. Um ein "Deadlock" zu verhindern
        werden alle WM_COMMAND Messages in den Klassen CODialog und COGrafikGruppe in
        eigenständigen Threads ausgeführt. Somit kann die Funktion pDialog-&gt;SetzSichtbar(true) in einer
        WM_COMMAND Message problemlos verwendet werden.
      </Text_n>
    </P>
    <P>
      <Text_n>Die Bibliothek Develop.dll ist zur Unterstützung von Enwicklern. Sie kann zur Laufzeit dazu geladen werden.</Text_n>
    </P>
    <P>
      <Text_n>
        Das Program Core verfügt über sein eigenes Speichermanagement sowie über einen eigenen
        Certificatestore. Beim Start eines Prozesses wird automatisch eine Verbindung zum Core hergestellt.
        Die Anzahl der verbundenen Prozesse ist auf achtzehn begrenzt. Für alle verbundenen Prozesse
        besteht die Möglichkeit mit der Klasse COVMBlockShared gemeinsam auf den gleichen
        Speicherbereich zuzugreifen.
      </Text_n>
</P>
    <P>
      <Text_n>
        Mein Prinzip der AES256bit Cryptography ist die Teilung von Schlüsselmanagement im Core und dem
        Codieralgorythmus beim jeweiligem Prozess. Die Schlüssel können von Core zu Core übertragen
        werden. Dies stellt dann auch die Datensicherung da, die ansonsten nicht weiter vorgesehen ist.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Der Core verfügt über eine eigene Databaseseengine. Diese hat ein Wartungsmodul mit zwei Aufgaben.
        Den "Perfekten Ausgleich"(PA) der Binare-Search-Tree(BST) und die Startoptimierung(SO) der
        Datenbankdateien. Letzters ist vergleichbar mit dem Defragmentieren von Datenträger. Beim Start des
        Cores durch den Service Manager erfolgt ein parallel Start der DB-Engine der zeitlich länger dauern
        kann. Dies ist nur über den Task Manager nachvollziehbar. Die SO dient nur der Beschleunigung des
        Startes der DB-Engine durch eine für den Start optimierte Anordnung der Daten in den DB-Dateien. Die
        SO selbst kann abhängig von Größe und Fragmentierung der DB-Dateien einige Minuten in Anspruch
        nehmen. Es empfiehlt sich den Vorgang manuell durchzuführen. Der PA der BSTs geht sehr schnell, da
        die BSTs sich im Cache der DB-Engine befinden und dabei nur "Zeiger umgehangen" und keine Daten
        verschoben werden. Der PA wird auch bei jedem Start des Cores ausgeführt. Diese beiden Aufgaben
        können auch automatisch zu einer vorgegeben Zeit ausgeführt werden, wenn beispielsweise der Core
        im 24/7 Betrieb läuft.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Die Cores kommunizieren untereinander über den Port 5111. Der Verbindungsaufbau zu
        IPV6-Addressen wird bevorzugt hergestellt und ist mindestens 1000 msek. schneller pro Verbindung.
        Die Standart Waittime zwischen Core zu Core Verbindungen beträgt 20000 msek. und zwischen
        Prozess zu Core 25000 msek. bevor der Vorgang abgebrochen wird.
      </Text_n>
    </P>
    <P>
      <Text_n>
        Neuerungen, Änderungen, Bugfixes: <A href="Release.txt">Release.txt</A><br>
      </Text_n>
    </P>
  </section>
</body>
</html>